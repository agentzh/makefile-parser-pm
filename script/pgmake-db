#!/usr/bin/env perl 

use strict;
use warnings;
use lib qw(/home/agentz/gmake-db/lib /home/agentz/mdom-gmake/lib);

#use Smart::Comments;
use Getopt::Long;
use Makefile::Parser::GmakeDB;
use IPC::Run3;
use File::Slurp;
use Makefile::AST::Evaluator;
use List::Util 'first';

my @DefaultMakefile = (
    'GNUmakefile',
    'makefile',
    'Makefile'
);

my ($makefile, $njobs, @goals);
Getopt::Long::Configure ("bundling");
GetOptions(
    'f|file|makefile=s' => \$makefile,
    'j=s' => \$njobs,  # job server is not really supported
    'n|just-print|dry-run|recon' => \$Makefile::AST::Evaluator::JustPrint,
    's|silent|quiet'  => \$Makefile::AST::Evaluator::Quiet,
    'i|ignore-errors' => \$Makefile::AST::Evaluator::IgnoreErrors,
) or die "Usage: $0 [-f makefile] goals...\n";
### $makefile
### @ARGV
if (!defined $makefile) {
    $makefile = first { -f $_ } @DefaultMakefile;
} elsif ($makefile ne '-' and !-f $makefile) {
    warn "$0: $makefile: No such file or directory\n";
    push @goals, $makefile; # This is required
    $Makefile::AST::Evaluator::Required{$makefile} = 1;
}
$makefile = 'Makefile' if !defined $makefile;

my $MAKE;
my @var_defs;
for my $arg (@ARGV) {
    if ($arg =~ /(.*?)=(.*)/) {
        my ($var, $value) = ($1, $2);
        if ($var eq 'MAKE') {
            $MAKE = $value;
        }
        push @var_defs, $arg;
    } else {
        push @goals, $arg;
    }
}
if (!defined $MAKE) {
    push @var_defs, "MAKE=$0";
}

### var defs via command line: @var_defs

my ($stdout, $stderr);
run3 ['make', '-pqRr', '-f', $makefile, @var_defs], undef, \$stdout, \$stderr;
## $stderr
my $exit_code = $? >> 8;
if ($stderr and $exit_code == 2 and $stderr !~ /^make:/) {
    $stderr =~ s/^make:/$0:/msg;
    warn $stderr;
    exit $exit_code;
}
if ($stderr =~ /warning: (overriding|ignoring old) commands for target/) {
    warn $stderr;
}

#die "GNU make stdout: $stdout\n";

# XXX debug only
write_file('/home/agentz/mdom-gmake/make.db', $stdout);

# patch the database output to work around gmake bugs
patch_database(\$stdout);

# XXX debug only
write_file('/home/agentz/mdom-gmake/make.db.patched', $stdout);

#if ($stdout =~ m{^\s*\./Makefile_\S+\s*:\s*[^\n]*$}ms) {
#    die $&;
#}
#print $stdout;
#exit 0;

$Makefile::AST::Runtime = 1;

my $ast = Makefile::Parser::GmakeDB->parse(\$stdout);
$ast->{makefile} = $makefile;
## $ast
## var a: $ast->get_var('a')
## var b: $ast->get_var('b')
#die;


push @goals, $ast->default_goal if !@goals;
### @goals
my $eval = Makefile::AST::Evaluator->new($ast);
for my $goal (@goals) {
    ### goal: $goal
    my $res = $eval->make($goal);
    ### result: $res
    if ($res and $res eq 'UP_TO_DATE') {
        print "$0: Nothing to be done for `$goal'.\n";
    }
}

# XXX promote the fixes on the GNU make side
sub patch_database {
    my $ref = shift;
    #$$ref =~ s/(\n\S+)#/$1\\#$2/gsm;
    $$ref =~ s/^(\S[^\n]*)(?<!\\)\\(\S[^\n]*\n#  Implicit rule search has)/$1\\:$2/msg;
    $$ref =~ s/^(\S[^\n]*)(?<!\\)#(\S[^\n]*\n#  Implicit rule search has)/$1\\#$2/msg;
    $$ref =~ s/^(\S[^\n]*)(?<!\\):(\S[^\n]*:\n#  Implicit rule search has)/$1\\:$2/msg;
}

