#!/usr/bin/env perl

use strict;
use warnings;
use lib 'lib';

#use Smart::Comments;
use Getopt::Long;
use Makefile::Parser::GmakeDB;
use IPC::Run3;
use File::Slurp;
use Makefile::AST::Evaluator;

my ($makefile, @goals);
GetOptions(
    'f=s' => \$makefile,
) or die "Usage: $0 [-f makefile] goals...\n";
### $makefile
### @ARGV
if (!-f $makefile) {
    warn "$0: $makefile: No such file or directory\n";
    push @goals, $makefile;
    $Makefile::AST::Evaluator::Required{$makefile} = 1;
}
$makefile = 'Makefile' if !defined $makefile;

my $stdout;
run3 ['make', '-pqRr', '-f', $makefile], \undef, \$stdout, \undef;

# XXX debug only
write_file('/home/agentz/mdom-gmake/make.db', $stdout);

#if ($stdout =~ m{^\s*\./Makefile_\S+\s*:\s*[^\n]*$}ms) {
#    die $&;
#}
#print $stdout;
#exit 0;

$Makefile::AST::Runtime = 1;

my $ast = Makefile::Parser::GmakeDB->parse(\$stdout);
$ast->{makefile} = $makefile;
## $ast
## var a: $ast->get_var('a')
## var b: $ast->get_var('b')
#die;

for my $arg (@ARGV) {
    if ($arg =~ /(.*?)=(.*)/) {
        my $var = Makefile::AST::Variable->new({
                name => $1,
                value => [$2],
                flavor => 'recursive', # XXX right flavor?
                origin => 'makefile', # XXX right origin?
            });
        $ast->add_var($var);
    } else {
        push @goals, $arg;
    }
}
push @goals, $ast->default_goal if !@goals;
### @goals
my $eval = Makefile::AST::Evaluator->new($ast);
for my $goal (@goals) {
    ### goal: $goal
    my $res = $eval->make($goal);
    ### result: $res
    if ($res eq 'UP_TO_DATE') {
        print "$0: Nothing to be done for `target'.\n";
    }
}

